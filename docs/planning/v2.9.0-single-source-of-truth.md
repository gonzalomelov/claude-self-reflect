# Claude Self-Reflect v2.9.0 - Single Source of Truth Architecture

**Created:** August 30, 2025  
**Status:** Planning  
**Target Release:** v2.9.0

## Executive Summary

Following the successful v2.8.0 release that fixed the MCP indexing status display issue through multi-file state reading, this document outlines the architectural improvements needed to establish a single source of truth for import state management.

## Current Architecture Issues

### Problem: Multiple State Files
The system currently maintains three separate state files:
1. `imported-files.json` - Batch importer state
2. `csr-watcher.json` - Streaming watcher local mode state  
3. `csr-watcher-cloud.json` - Streaming watcher cloud mode state

### Consequences
- **Complexity**: Reading and merging from multiple sources
- **Performance**: I/O overhead reading 3+ files on each status check
- **Consistency**: Risk of state divergence between files
- **Debugging**: Difficult to trace source of truth
- **Concurrency**: File locking issues with multiple writers

## Proposed Solution: SQLite State Store

### Architecture
Replace multiple JSON files with a single SQLite database:

```sql
-- config/state.db schema
CREATE TABLE imported_files (
    file_path TEXT PRIMARY KEY,
    imported_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    chunks INTEGER DEFAULT 0,
    source TEXT CHECK(source IN ('batch', 'watcher_local', 'watcher_cloud')),
    metadata JSON,
    last_modified TIMESTAMP,
    INDEX idx_imported_at (imported_at),
    INDEX idx_source (source)
);

CREATE TABLE import_progress (
    id INTEGER PRIMARY KEY,
    total_files INTEGER,
    indexed_files INTEGER,
    percentage REAL,
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE watcher_state (
    watcher_id TEXT PRIMARY KEY,
    status TEXT CHECK(status IN ('active', 'inactive', 'error')),
    last_heartbeat TIMESTAMP,
    files_processed INTEGER DEFAULT 0,
    memory_usage_mb REAL,
    configuration JSON
);
```

### Benefits

#### 1. **Atomic Transactions**
- No partial writes or corrupted state
- ACID compliance ensures data integrity
- Rollback capability for failed imports

#### 2. **Performance**
- Single file I/O operation
- Efficient indexing and queries
- Built-in caching mechanisms
- Scales to millions of files

#### 3. **Concurrency**
- Proper locking mechanisms
- Multiple readers, single writer model
- No file corruption from concurrent access

#### 4. **Querying Capabilities**
- Complex queries for analytics
- Efficient filtering and aggregation
- Time-based queries for historical data

#### 5. **Maintainability**
- Standard SQL interface
- Easy backup and restore
- Migration path for schema changes

## Implementation Plan

### Phase 1: Database Layer (Week 1)
```python
# scripts/state_manager.py
class StateManager:
    def __init__(self, db_path: Path = Path.home() / ".claude-self-reflect" / "config" / "state.db"):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self._init_schema()
    
    def add_imported_file(self, file_path: str, chunks: int, source: str):
        """Add or update imported file record"""
        
    def get_indexing_status(self) -> Dict:
        """Get current indexing status"""
        
    def update_watcher_state(self, watcher_id: str, status: str):
        """Update watcher heartbeat and status"""
```

### Phase 2: Migration Script (Week 1)
```python
# scripts/migrate_to_sqlite.py
def migrate_json_to_sqlite():
    """One-time migration from JSON files to SQLite"""
    # 1. Read all existing JSON state files
    # 2. Merge and deduplicate data
    # 3. Insert into SQLite database
    # 4. Backup old JSON files
    # 5. Verify migration success
```

### Phase 3: Update Components (Week 2)
1. Update `mcp-server/src/server.py` to use StateManager
2. Update `scripts/import-conversations-unified.py`
3. Update `scripts/streaming-watcher.py`
4. Update `scripts/status.py`

### Phase 4: Backwards Compatibility (Week 2)
```python
class LegacyStateAdapter:
    """Adapter to maintain backwards compatibility during transition"""
    def __init__(self, state_manager: StateManager):
        self.state_manager = state_manager
        
    def write_json_snapshot(self):
        """Write current state to JSON for legacy tools"""
```

## Migration Strategy

### For New Installations
- SQLite database created automatically
- No JSON files needed
- Clean, efficient state management

### For Existing Installations
1. **Automatic Detection**: Check for existing JSON files
2. **Migration Prompt**: Ask user to migrate (with backup)
3. **Parallel Operation**: Support both during transition period
4. **Verification**: Compare counts before/after migration
5. **Cleanup**: Archive old JSON files after successful migration

## Performance Improvements

### Current (v2.8.0)
- Read 3+ JSON files: ~50-100ms
- Parse and merge: ~20-30ms  
- Path normalization: ~10ms
- Total: ~80-140ms per status check

### Proposed (v2.9.0)
- Single SQLite query: ~5-10ms
- No parsing needed
- Cached prepared statements
- Total: ~5-10ms per status check

**Expected improvement: 10-20x faster status checks**

## Risk Mitigation

### Data Loss Prevention
- Automatic backups before migration
- Transaction rollbacks on errors
- JSON snapshot fallback option

### Compatibility
- Gradual rollout with feature flag
- Parallel JSON writing during transition
- Clear migration documentation

### Testing Strategy
1. Unit tests for StateManager
2. Integration tests for migration
3. Performance benchmarks
4. Load testing with 100k+ files
5. Concurrent access stress testing

## Success Metrics

- [ ] Single source of truth established
- [ ] Status check latency < 10ms
- [ ] Zero data loss during migration
- [ ] Support for 1M+ files
- [ ] Concurrent access without corruption
- [ ] 90% reduction in state-related bugs

## Timeline

- **Week 1**: Database layer + migration script
- **Week 2**: Component updates + compatibility layer
- **Week 3**: Testing and documentation
- **Week 4**: Beta release to early adopters
- **Week 5**: Production release v2.9.0

## Alternative Approaches Considered

### 1. Redis/KeyDB
- **Pros**: Fast, distributed
- **Cons**: Additional dependency, complex setup

### 2. PostgreSQL
- **Pros**: Full SQL, robust
- **Cons**: Overkill for state management, heavy dependency

### 3. JSON with File Locking
- **Pros**: Simple, no new dependencies
- **Cons**: Doesn't solve core issues

### 4. LMDB
- **Pros**: Very fast, embedded
- **Cons**: Less familiar, limited tooling

**SQLite chosen for**: Zero dependencies, proven reliability, SQL interface, excellent Python support

## Conclusion

The move to a single SQLite-based source of truth will significantly improve the reliability, performance, and maintainability of Claude Self-Reflect's state management. This architectural improvement sets the foundation for future features like distributed deployments and advanced analytics.

## Next Steps

1. Review and approve this design document
2. Create implementation tickets
3. Begin Phase 1 development
4. Set up testing infrastructure
5. Communicate changes to users

---

**Document maintained by:** Claude Self-Reflect Core Team  
**Last updated:** August 30, 2025